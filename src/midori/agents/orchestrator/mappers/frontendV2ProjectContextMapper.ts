/**
 * Frontend-V2 to Project Context Mapper
 * แปลงข้อมูลจาก Frontend-V2 เป็น Project Context format
 */

import { ComponentResultV2 } from '../../frontend-v2/schemas/types';
import { 
  ComponentStateData, 
  PageStateData, 
  PreviewData,
  FrontendV2ProjectData
} from '../types/projectContext';
import { ComponentType, PageType } from '@prisma/client';

export class FrontendV2ProjectContextMapper {
  /**
   * แปลง Frontend-V2 result เป็น Project Context format
   */
  static mapResultToProjectContext(frontendResult: ComponentResultV2): {
    frontendV2Data: FrontendV2ProjectData;
    components: ComponentStateData[];
    pages: PageStateData[];
    preview: PreviewData | null;
  } {
    return {
      frontendV2Data: this.mapToFrontendV2ProjectData(frontendResult),
      components: this.mapFilesToComponents(frontendResult.files),
      pages: this.mapProjectStructureToPages(frontendResult.projectStructure),
      preview: this.mapPreviewToProjectContext(frontendResult.preview)
    };
  }

  /**
   * แปลง Frontend-V2 result เป็น FrontendV2ProjectData
   */
  private static mapToFrontendV2ProjectData(frontendResult: ComponentResultV2): FrontendV2ProjectData {
    return {
      businessCategory: frontendResult.result.businessCategory,
      projectType: frontendResult.result.projectType,
      templateUsed: frontendResult.result.templateUsed,
      blocksGenerated: frontendResult.result.blocksGenerated,
      aiContentGenerated: frontendResult.result.aiContentGenerated,
      customizationsApplied: frontendResult.result.customizationsApplied,
      overridesApplied: frontendResult.result.overridesApplied,
      files: frontendResult.files,
      projectStructure: frontendResult.projectStructure,
      preview: frontendResult.preview,
      performance: frontendResult.performance,
      validation: frontendResult.validation,
      metadata: frontendResult.metadata
    };
  }

  /**
   * แปลง Frontend-V2 files เป็น Project Context components
   */
  private static mapFilesToComponents(files: ComponentResultV2['files']): ComponentStateData[] {
    return files
      .filter(file => file.type === 'component')
      .map(file => ({
        id: this.generateId(),
        componentId: file.blockId,
        name: this.extractComponentName(file.path),
        type: this.mapBlockIdToComponentType(file.blockId),
        location: {
          page: this.extractPageFromPath(file.path),
          section: 'main',
          position: 0
        },
        props: this.extractPropsFromContent(file.content),
        styling: this.extractStylingFromContent(file.content),
        metadata: {
          version: '1.0.0',
          lastModified: new Date(),
          createdBy: 'frontend-v2',
          tags: [file.blockId],
          description: `Component generated by Frontend-V2: ${file.blockId}`
        },
        createdAt: new Date(),
        updatedAt: new Date()
      }));
  }

  /**
   * แปลง Frontend-V2 project structure เป็น Project Context pages
   */
  private static mapProjectStructureToPages(projectStructure: ComponentResultV2['projectStructure']): PageStateData[] {
    if (!projectStructure) return [];
    
    return projectStructure.files
      .filter(file => this.isPageFile(file.path))
      .map(file => ({
        id: this.generateId(),
        pageId: this.extractPageId(file.path),
        name: this.extractPageName(file.path),
        path: this.extractPagePath(file.path),
        type: this.mapPathToPageType(file.path),
        components: this.extractComponentIdsFromContent(file.content),
        layout: {
          type: 'grid',
          columns: 1,
          gap: '1rem'
        },
        metadata: {
          title: this.extractPageTitle(file.content),
          lastModified: new Date(),
          createdBy: 'frontend-v2'
        },
        createdAt: new Date(),
        updatedAt: new Date()
      }));
  }

  /**
   * แปลง Frontend-V2 preview เป็น Project Context preview
   */
  private static mapPreviewToProjectContext(frontendPreview: ComponentResultV2['preview']): PreviewData | null {
    if (!frontendPreview) return null;
    
    return {
      sandboxId: frontendPreview.sandboxId,
      previewUrl: frontendPreview.url,
      status: this.mapPreviewStatus(frontendPreview.status),
      error: frontendPreview.error,
      createdAt: new Date(frontendPreview.createdAt),
      lastUpdated: new Date(),
      metadata: {
        projectType: 'vite-react-typescript',
        templateUsed: 'frontend-v2',
        filesCount: 0, // Will be updated
        buildTime: 0   // Will be updated
      }
    };
  }

  // ============================
  // Helper Methods
  // ============================

  private static generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private static extractComponentName(path: string): string {
    const fileName = path.split('/').pop()?.replace('.tsx', '').replace('.jsx', '') || 'Unknown';
    return fileName.charAt(0).toUpperCase() + fileName.slice(1);
  }

  private static mapBlockIdToComponentType(blockId: string): ComponentType {
    const mapping: Record<string, ComponentType> = {
      'hero-basic': 'hero',
      'navbar-basic': 'header',
      'footer-basic': 'footer',
      'card-basic': 'card',
      'menu-basic': 'menu',
      'about-basic': 'about',
      'contact-basic': 'contact',
      'testimonial-basic': 'testimonial',
      'pricing-basic': 'pricing',
      'gallery-basic': 'gallery'
    };
    return mapping[blockId] || 'custom';
  }

  private static extractPageFromPath(path: string): string {
    if (path.includes('pages/')) {
      return path.split('/').slice(-2, -1)[0] || 'home';
    }
    return 'home';
  }

  private static extractPropsFromContent(content: string): Record<string, any> {
    // Extract props from React component content
    const propsMatch = content.match(/interface\s+\w+Props\s*\{([^}]+)\}/);
    if (propsMatch) {
      const propsString = propsMatch[1];
      const props: Record<string, any> = {};
      propsString.split('\n').forEach(line => {
        const match = line.match(/(\w+)\??:\s*(\w+)/);
        if (match) {
          props[match[1]] = match[2];
        }
      });
      return props;
    }
    return {};
  }

  private static extractStylingFromContent(content: string): any {
    // Extract styling information from component content
    return {
      colors: {},
      fonts: {},
      spacing: {},
      borders: {},
      shadows: {}
    };
  }

  private static isPageFile(path: string): boolean {
    return path.includes('pages/') || path === 'src/App.tsx' || path.includes('routes/');
  }

  private static extractPageId(path: string): string {
    const fileName = path.split('/').pop()?.replace('.tsx', '').replace('.jsx', '') || 'unknown';
    return fileName.toLowerCase();
  }

  private static extractPageName(path: string): string {
    const fileName = path.split('/').pop()?.replace('.tsx', '').replace('.jsx', '') || 'Unknown';
    return fileName.charAt(0).toUpperCase() + fileName.slice(1);
  }

  private static extractPagePath(path: string): string {
    if (path === 'src/App.tsx') return '/';
    if (path.includes('pages/')) {
      const pageName = path.split('/').pop()?.replace('.tsx', '').replace('.jsx', '') || 'home';
      return `/${pageName.toLowerCase()}`;
    }
    return '/';
  }

  private static mapPathToPageType(path: string): PageType {
    const mapping: Record<string, PageType> = {
      'App.tsx': 'home',
      'Home.tsx': 'home',
      'About.tsx': 'about',
      'Contact.tsx': 'contact',
      'Menu.tsx': 'menu',
      'Products.tsx': 'products',
      'Services.tsx': 'services',
      'Blog.tsx': 'blog',
      'Gallery.tsx': 'gallery'
    };
    
    const fileName = path.split('/').pop() || '';
    return mapping[fileName] || 'custom';
  }

  private static extractComponentIdsFromContent(content: string): string[] {
    // Extract component imports and usage from content
    const imports = content.match(/import\s+.*?\s+from\s+['"]([^'"]+)['"]/g);
    if (imports) {
      return imports.map(imp => {
        const match = imp.match(/import\s+\{?\s*(\w+)/);
        return match ? match[1] : '';
      }).filter(Boolean);
    }
    return [];
  }

  private static extractPageTitle(content: string): string {
    const titleMatch = content.match(/<title[^>]*>([^<]+)<\/title>/);
    if (titleMatch) {
      return titleMatch[1];
    }
    
    const h1Match = content.match(/<h1[^>]*>([^<]+)<\/h1>/);
    if (h1Match) {
      return h1Match[1];
    }
    
    return 'Untitled Page';
  }

  private static mapPreviewStatus(status: 'pending' | 'ready' | 'error'): 'creating' | 'running' | 'error' | 'stopped' | 'expired' {
    const mapping: Record<string, 'creating' | 'running' | 'error' | 'stopped' | 'expired'> = {
      'pending': 'creating',
      'ready': 'running',
      'error': 'error'
    };
    return mapping[status] || 'creating';
  }
}
